# -*- coding: utf-8 -*-
"""ALTSCH_MongoDB.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1I-aR_JTh-MNmYeY5qy8cZt0pg5inKaL6
"""

pip install pymongo

pip install pymongo faker pandas

"""# Create and Insert Users (Students and Instructors)"""

from pymongo import MongoClient
from faker import Faker
import random
from datetime import datetime

fake = Faker()

client = MongoClient("mongodb+srv://Eduhub_user:2025Alt@altschexam.pmhg2or.mongodb.net/?retryWrites=true&w=majority&appName=ALTSCHEXAM")
db = client['Eduhub_db']
users_col = db['users']

roles = ['student', 'instructor']
users = []

for _ in range(20):
    role = random.choice(roles)
    user = {
        "userId": fake.uuid4(),
        "email": fake.unique.email(),
        "firstName": fake.first_name(),
        "lastName": fake.last_name(),
        "role": role,
        "dateJoined": fake.date_time_between(start_date='-1y', end_date='now'),
        "profile": {
            "bio": fake.text(),
            "avatar": fake.image_url(),
            "skills": fake.words(nb=3)
        },
        "isActive": True
    }
    users.append(user)

users_col.insert_many(users)

"""# Create Sample Courses"""

courses_col = db['courses']
instructor_ids = [user["userId"] for user in users if user["role"] == "instructor"]

categories = ["Data Science", "Programming", "AI", "Math", "Business"]
levels = ["beginner", "intermediate", "advanced"]

courses = []

for i in range(8):
    course = {
        "courseId": fake.uuid4(),
        "title": fake.sentence(nb_words=5),
        "description": fake.text(),
        "instructorId": random.choice(instructor_ids),
        "category": random.choice(categories),
        "level": random.choice(levels),
        "duration": random.randint(5, 50),
        "price": round(random.uniform(20, 200), 2),
        "tags": fake.words(nb=3),
        "createdAt": datetime.now(),
        "updatedAt": datetime.now(),
        "isPublished": random.choice([True, False])
    }
    courses.append(course)

courses_col.insert_many(courses)

"""# Insert Sample Enrollments"""

enrollments_col = db['enrollments']

# Get only student userIds
student_ids = [user["userId"] for user in users if user["role"] == "student"]
course_ids = [course["courseId"] for course in courses]

enrollments = []

for _ in range(15):  # Create 15 enrollments
    enrollment = {
        "enrollmentId": fake.uuid4(),
        "studentId": random.choice(student_ids),
        "courseId": random.choice(course_ids),
        "enrolledAt": fake.date_time_between(start_date='-6mo', end_date='now'),
        "progress": round(random.uniform(0, 100), 2),
        "completionStatus": random.choice(["in progress", "completed", "not started"])
    }
    enrollments.append(enrollment)

enrollments_col.insert_many(enrollments)

"""# Insert Sample Lessons"""

lessons_col = db['lessons']

lessons = []

for course in courses:
    for i in range(random.randint(2, 5)):  # 2 to 5 lessons per course
        lesson = {
            "lessonId": fake.uuid4(),
            "courseId": course["courseId"],
            "title": f"Lesson {i+1} - {fake.sentence(nb_words=4)}",
            "content": fake.paragraph(nb_sentences=5),
            "duration": random.randint(10, 60),  # in minutes
            "createdAt": datetime.now()
        }
        lessons.append(lesson)

lessons_col.insert_many(lessons)

"""# Insert Sample Assignments"""

assignments_col = db['assignments']

assignments = []

for course in courses:
    for i in range(random.randint(1, 2)):  # 1–2 assignments per course
        assignment = {
            "assignmentId": fake.uuid4(),
            "courseId": course["courseId"],
            "title": f"Assignment {i+1} - {fake.bs().title()}",
            "description": fake.paragraph(nb_sentences=3),
            "dueDate": fake.date_time_between(start_date='now', end_date='+1mo'),
            "maxScore": 100,
            "createdAt": datetime.now()
        }
        assignments.append(assignment)

assignments_col.insert_many(assignments)

"""# Insert Sample Submissions"""

submissions_col = db['submissions']

# Map course to enrolled students
course_enrollments = {}
for enr in enrollments:
    course_enrollments.setdefault(enr['courseId'], []).append(enr['studentId'])

submissions = []

for assignment in assignments:
    enrolled_students = course_enrollments.get(assignment['courseId'], [])
    if not enrolled_students:
        continue

    # Select a few students to simulate submissions
    for student in random.sample(enrolled_students, k=min(2, len(enrolled_students))):
        submission = {
            "submissionId": fake.uuid4(),
            "assignmentId": assignment['assignmentId'],
            "studentId": student,
            "submittedAt": fake.date_time_between(start_date='-1mo', end_date='now'),
            "content": fake.paragraph(nb_sentences=5),
            "grade": random.randint(50, 100),
            "feedback": fake.sentence()
        }
        submissions.append(submission)

submissions_col.insert_many(submissions)

"""# Schema Design – Define the Structure for Each Collection"""

{
  "userId": "string (unique)",
  "email": "string (required, unique)",
  "firstName": "string",
  "lastName": "string",
  "role": "string (student/instructor)",
  "dateJoined": "datetime",
  "profile": {
    "bio": "string",
    "avatar": "string",
    "skills": ["string"]
  },
  "isActive": "boolean"
}

"""# Add Schema Validation with PyMongo"""

user_schema = {
    "$jsonSchema": {
        "bsonType": "object",
        "required": ["userId", "email", "firstName", "lastName", "role", "dateJoined", "isActive"],
        "properties": {
            "userId": {"bsonType": "string"},
            "email": {"bsonType": "string", "description": "must be a string and is required"},
            "firstName": {"bsonType": "string"},
            "lastName": {"bsonType": "string"},
            "role": {"enum": ["student", "instructor"]},
            "dateJoined": {"bsonType": "date"},
            "isActive": {"bsonType": "bool"},
            "profile": {
                "bsonType": "object",
                "properties": {
                    "bio": {"bsonType": "string"},
                    "avatar": {"bsonType": "string"},
                    "skills": {
                        "bsonType": "array",
                        "items": {"bsonType": "string"}
                    }
                }
            }
        }
    }
}

# Apply schema to new collection
db.create_collection("collMod", validator=user_schema)

db.command({
    "collMod": "users",
    "validator": user_schema
})

"""# Recreate the instructors and students Lists"""

# Re-fetch users from the database
users = list(db.users.find({}))

# Separate them by role
instructors = [u for u in users if u['role'] == 'instructor']
students = [u for u in users if u['role'] == 'student']

"""# Perform CRUD Operations with PyMongo"""

# Add a new student user
db.users.insert_one({
    "userId": fake.uuid4(),
    "email": fake.email(),
    "firstName": fake.first_name(),
    "lastName": fake.last_name(),
    "role": "student",
    "dateJoined": datetime.now(),
    "profile": {"bio": "", "avatar": "", "skills": []},
    "isActive": True
})

# Create a new course
db.courses.insert_one({
    "courseId": fake.uuid4(),
    "title": "New Python Basics",
    "description": "Intro to Python.",
    "instructorId": instructors[0]['userId'],
    "category": "Programming",
    "level": "beginner",
    "duration": 5,
    "price": 0,
    "tags": ["python", "beginner"],
    "createdAt": datetime.now(),
    "updatedAt": datetime.now(),
    "isPublished": False
})

# Enroll a student
db.enrollments.insert_one({
    "enrollmentId": fake.uuid4(),
    "studentId": students[0]['userId'],
    "courseId": courses[0]['courseId'],
    "enrolledAt": datetime.now(),
    "progress": 0,
    "completionStatus": "not started"
})

# Add a lesson to a course
db.lessons.insert_one({
    "lessonId": fake.uuid4(),
    "courseId": courses[0]['courseId'],
    "title": "Lesson: Variables",
    "content": "Understanding variables in Python.",
    "duration": 30,
    "createdAt": datetime.now()
})

"""# Read Operations (Queries with PyMongo)

## 1. Find All Active Students
"""

active_students = list(db.users.find({"role": "student", "isActive": True}))
for student in active_students:
    print(student['firstName'], student['email'])

"""## 2. Retrieve Course Details with Instructor Info"""

from bson import ObjectId

pipeline = [
    {
        "$lookup": {
            "from": "users",
            "localField": "instructorId",
            "foreignField": "userId",
            "as": "instructor"
        }
    },
    {"$unwind": "$instructor"},
    {"$project": {
        "title": 1,
        "category": 1,
        "instructorName": {"$concat": ["$instructor.firstName", " ", "$instructor.lastName"]}
    }}
]

course_details = list(db.courses.aggregate(pipeline))
for course in course_details:
    print(course)

"""## 3. Get All Courses in a Category"""

programming_courses = list(db.courses.find({"category": "Programming"}))

programming_courses

"""## 4. Find Students Enrolled in a Particular Course"""

course_id = courses[0]['courseId']

enrolled_students = list(db.enrollments.find({"courseId": course_id}))
for enrollment in enrolled_students:
    print(enrollment['studentId'])

"""## 5. Search Courses by Title (Partial Match, Case-Insensitive)"""

search_text = "python"
matched_courses = list(db.courses.find({"title": {"$regex": search_text, "$options": "i"}}))
for course in matched_courses:
    print(course['title'])

"""# Complex Queries"""

# 1. Courses with price between $50 and $200
courses_in_range = db.courses.find({"price": {"$gte": 50, "$lte": 200}})

for item in courses_in_range:
    print(item)

# 2. Users who joined in the last 6 months
from datetime import datetime, timedelta

six_months_ago = datetime.now() - timedelta(days=180)
recent_users = db.users.find({"dateJoined": {"$gte": six_months_ago}})

for user in recent_users:
    print(user)

# 3. Courses that have specific tags
courses_with_tags = db.courses.find({"tags": {"$in": ["python", "data science"]}})

for tag in courses_with_tags:
    print(tag)

# 4. Assignments with due dates in the next week
next_week = datetime.now() + timedelta(days=7)
upcoming_assignments = db.assignments.find({"dueDate": {"$lte": next_week}})

for ass in upcoming_assignments:
    print(ass)

"""# Aggregation Pipelines

## Course Enrollment Statistics
"""

# Course Enrollment Statistics
# Count total enrollments per course
enrollment_stats = db.enrollments.aggregate([
    {"$group": {
        "_id": "$courseId",
        "totalEnrollments": {"$sum": 1}
    }}
])

# Calculate average course rating (assuming each enrollment has a rating field)
avg_ratings = db.enrollments.aggregate([
    {"$group": {
        "_id": "$courseId",
        "avgRating": {"$avg": "$rating"}
    }}
])

# Group by course category
category_stats = db.courses.aggregate([
    {"$group": {
        "_id": "$category",
        "totalCourses": {"$sum": 1}
    }}
])

"""## Student Performance Analysis"""

# Student Performance Analysis
# Average grade per student
avg_grade_per_student = db.submissions.aggregate([
    {"$group": {
        "_id": "$studentId",
        "avgGrade": {"$avg": "$grade"}
    }}
])

# Completion rate by course
completion_rate = db.enrollments.aggregate([
    {"$group": {
        "_id": "$courseId",
        "completed": {"$sum": {"$cond": [{"$eq": ["$completionStatus", "completed"]}, 1, 0]}},
        "total": {"$sum": 1}
    }},
    {"$project": {
        "completionRate": {"$divide": ["$completed", "$total"]}
    }}
])

# Top-performing students (e.g., average grade > 90)
top_students = db.submissions.aggregate([
    {"$group": {
        "_id": "$studentId",
        "avgGrade": {"$avg": "$grade"}
    }},
    {"$match": {"avgGrade": {"$gte": 90}}}
])

"""## Instructor Analytics"""

# Instructor Analytics
# Total students taught by each instructor
instructor_students = db.courses.aggregate([
    {"$lookup": {
        "from": "enrollments",
        "localField": "courseId",
        "foreignField": "courseId",
        "as": "enrollments"
    }},
    {"$unwind": "$enrollments"},
    {"$group": {
        "_id": "$instructorId",
        "studentsTaught": {"$addToSet": "$enrollments.studentId"}
    }},
    {"$project": {
        "totalStudents": {"$size": "$studentsTaught"}
    }}
])

# Average course rating per instructor
avg_instructor_rating = db.courses.aggregate([
    {"$lookup": {
        "from": "enrollments",
        "localField": "courseId",
        "foreignField": "courseId",
        "as": "ratings"
    }},
    {"$unwind": "$ratings"},
    {"$group": {
        "_id": "$instructorId",
        "avgRating": {"$avg": "$ratings.rating"}
    }}
])

# Revenue generated per instructor (assuming course price is revenue per enrollment)
revenue_per_instructor = db.courses.aggregate([
    {"$lookup": {
        "from": "enrollments",
        "localField": "courseId",
        "foreignField": "courseId",
        "as": "enrollments"
    }},
    {"$unwind": "$enrollments"},
    {"$group": {
        "_id": "$instructorId",
        "revenue": {"$sum": "$price"}
    }}
])

"""## Advanced Analytics"""

# Advanced Analytics
# Monthly enrollment trends
monthly_trends = db.enrollments.aggregate([
    {"$group": {
        "_id": {"$dateToString": {"format": "%Y-%m", "date": "$enrollmentDate"}},
        "count": {"$sum": 1}
    }},
    {"$sort": {"_id": 1}}
])

# Most popular course categories
popular_categories = db.courses.aggregate([
    {"$lookup": {
        "from": "enrollments",
        "localField": "courseId",
        "foreignField": "courseId",
        "as": "enrollments"
    }},
    {"$group": {
        "_id": "$category",
        "enrollmentCount": {"$sum": {"$size": "$enrollments"}}
    }},
    {"$sort": {"enrollmentCount": -1}}
])

# Student engagement metrics (e.g., average number of submissions per student)
student_engagement = db.submissions.aggregate([
    {"$group": {
        "_id": "$studentId",
        "totalSubmissions": {"$sum": 1}
    }},
    {"$group": {
        "_id": None,
        "avgSubmissions": {"$avg": "$totalSubmissions"}
    }}
])

"""# Index Creation

### User Email Lookup
"""

db.users.create_index("email", unique=True)

"""### Course Search by Title and Category"""

db.courses.create_index([("title", 1), ("category", 1)])

"""### Assignment Queries by Due Date"""

db.assignments.create_index("dueDate")

"""### Enrollment Queries by Student and Course"""

db.enrollments.create_index([("studentId", 1), ("courseId", 1)])

"""# Query Optimization"""

# Analyze query performance
explain_result = db.courses.find({"category": "Programming"}).explain()
print(explain_result)

# Measure execution time
import time

start = time.time()
list(db.courses.find({"category": "Programming"}))
end = time.time()

print(f"Execution time: {end - start:.4f} seconds")

"""# Schema Validation Rules"""

# Create users collection with validation:
db.create_collection("users_validated", validator={
    "$jsonSchema": {
        "bsonType": "object",
        "required": ["userId", "email", "firstName", "lastName", "role"],
        "properties": {
            "email": {
                "bsonType": "string",
                "pattern": "^.+@.+$",
                "description": "Must be a valid email"
            },
            "role": {
                "enum": ["student", "instructor"],
                "description": "Must be either 'student' or 'instructor'"
            },
            "isActive": {"bsonType": "bool"}
        }
    }
})

"""# Error Handling in PyMongo"""

# Duplicate key error
from pymongo.errors import DuplicateKeyError
from datetime import datetime
import uuid

new_user = {
    "userId": str(uuid.uuid4()),
    "email": "existing@email.com",  # duplicate for test
    "firstName": "John",
    "lastName": "Doe",
    "role": "student",
    "dateJoined": datetime.now(),
    "isActive": True
}

try:
    db.users.insert_one(new_user)
except DuplicateKeyError as e:
    print("Duplicate email error:", e)

# Required field missing
try:
    db.users.insert_one({"email": "test@test.com"})  # missing required fields
except Exception as e:
    print("Insert failed:", e)

"""# Python Script to Export MongoDB Collections to JSON"""

from bson import json_util

# List of all collections
collections = ["users", "courses", "enrollments", "lessons", "assignments", "submissions"]

# Export each collection to a separate JSON file
for collection_name in collections:
    data = list(db[collection_name].find({}))

    with open(f"{collection_name}.json", "w") as file:
        json.dump(data, file, default=json_util.default, indent=4)

print("Export completed successfully.")

